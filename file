// blog_detail.js
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded: Initializing blog_detail.js');

    // --- Global Variables from Django Context (set in blog_detail.html) ---
    // Ensure these are correctly rendered in your HTML for the JS to pick them up
    const USER_IS_AUTHENTICATED = window.USER_IS_AUTHENTICATED === 'true';
    const USER_FULL_NAME = window.USER_FULL_NAME || '';
    const USER_EMAIL = window.USER_EMAIL || '';
    // Capture POST_SLUG and POST_ID directly from window, as set in the HTML <script> block
    const postSlug = window.POST_SLUG || null;
    const blogPostId = window.POST_ID || null;


    console.log('USER_IS_AUTHENTICATED:', USER_IS_AUTHENTICATED);
    console.log('USER_FULL_NAME:', USER_FULL_NAME);
    console.log('USER_EMAIL:', USER_EMAIL);
    console.log('postSlug from window:', postSlug);
    console.log('blogPostId from window:', blogPostId);

    // --- DOM Elements ---
    const commentsList = document.getElementById('comments-list');
    const commentForm = document.getElementById('comment-form');
    
    // Corrected selector for the like button!
    const likeButton = document.querySelector('.like-btn'); 
    // Ensure likeCountSpan is only queried if likeButton exists
    const likeCountSpan = likeButton ? likeButton.querySelector('.like-count') : null;
    // Note: Your HTML uses .comment-count inside .content-actions directly for the total count badge
    // I'll keep the .comments-count .count-value for consistency with your JS, assuming that's intended for the section header
    const commentsCountSpan = document.querySelector('.comment-count-badge'); 
    // Fallback for commentsCountSpan if .comment-count-badge is not the desired element
    if (!commentsCountSpan) {
        console.warn('Comments count badge (.comment-count-badge) not found. Falling back to .comment-count in content-actions.');
        // If the above isn't right, you might need this:
        // commentsCountSpan = document.querySelector('.content-actions .comment-count');
        // If the count is in the main content-actions comment button
    }


    console.log('likeButton found:', !!likeButton); // true if element exists, false otherwise
    console.log('likeCountSpan found:', !!likeCountSpan);
    console.log('commentsCountSpan (for total) found:', !!commentsCountSpan);


    const progressBar = document.getElementById('progress-bar');
    const backToTop = document.getElementById('back-to-top');

    // --- Helper for Toast Notifications ---
    function showToast(message, type = 'success') {
        let toast = document.getElementById('toast-message');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'toast-message';
            toast.className = 'toast';
            document.body.appendChild(toast);
        }
        toast.textContent = message;
        toast.className = `toast show ${type}`;

        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300); // Match CSS transition duration for fade-out
        }, 3000); // Display duration
    }

    // --- Helper function to get CSRF token ---
    function getCookie(name) {
        // Prefer the CSRF_TOKEN from window global if available, as set by Django
        if (name === 'csrftoken' && window.CSRF_TOKEN) {
            console.log('Using CSRF_TOKEN from window global.');
            return window.CSRF_TOKEN;
        }

        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        console.log(`CSRF Token (${name}):`, cookieValue ? 'Found' : 'Not Found (from cookie fallback)');
        return cookieValue;
    }

    // --- Comment Form Submission (Main Form) ---
    if (commentForm) {
        commentForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            console.log('Main comment form submitted.');

            const formData = new FormData(this);
            const submitButton = this.querySelector('button[type="submit"]');
            const originalButtonText = submitButton.innerHTML;
            
            // Show loading state
            submitButton.disabled = true;
            submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Posting...';

            // If user is authenticated, remove name/email from FormData
            // as they are handled by Django's User model and might be readOnly on frontend
            if (USER_IS_AUTHENTICATED) {
                formData.delete('name');
                formData.delete('email');
                console.log('User is authenticated, removed name/email from main comment form data.');
            }

            try {
                const response = await fetch(this.action, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRFToken': getCookie('csrftoken') // Ensure CSRF token is sent
                    }
                });

                const result = await response.json();
                console.log('Main comment form response:', result);

                if (result.success) {
                    showToast('Comment posted successfully!', 'success');
                    const newCommentHtml = createCommentElement(result.comment);

                    // Update comment count
                    if (commentsCountSpan) {
                        commentsCountSpan.textContent = parseInt(commentsCountSpan.textContent || '0') + 1;
                        console.log('Comments count updated:', commentsCountSpan.textContent);
                    }

                    commentsList.insertAdjacentHTML('afterbegin', newCommentHtml);
                    
                    // If "No comments yet" message exists, remove it
                    const noCommentsMsg = document.querySelector('.no-comments');
                    if (noCommentsMsg) {
                        noCommentsMsg.remove();
                        console.log('Removed "No comments yet" message.');
                    }

                    this.reset(); // Clear form
                    // Hide any active reply forms (if open)
                    document.querySelectorAll('.comment-reply-form').forEach(form => form.style.display = 'none');

                    setupCommentReplies(); // Re-attach listeners for all buttons, including newly added
                } else {
                    if (result.errors) {
                        let errorMessages = '';
                        // Iterate through errors to build a user-friendly message
                        for (const field in result.errors) {
                            // You might want to map 'name' to 'Name' for better display
                            let fieldName = field.charAt(0).toUpperCase() + field.slice(1);
                            errorMessages += `${fieldName}: ${result.errors[field].join(', ')}\n`;
                        }
                        showToast(`Error: ${errorMessages.trim()}`, 'error');
                        console.error('Main comment form submission errors:', result.errors);
                    } else {
                        showToast('Failed to post comment. Please try again.', 'error');
                        console.error('Main comment form submission failed:', result);
                    }
                }
            } catch (error) {
                console.error('Network or server error submitting main comment form:', error);
                showToast('A network error occurred. Please try again.', 'error');
            } finally {
                submitButton.disabled = false;
                submitButton.innerHTML = originalButtonText;
            }
        });
    } else {
        console.warn('Comment form (#comment-form) not found. Comment submission disabled.');
    }

    // --- Create Comment Element (HTML for new comments/replies) ---
    // This function generates the HTML structure for a comment, including its reply form.
    // The name/email inputs in the reply form are pre-filled/readonly based on JS global vars.
    function createCommentElement(commentData) {
        // Default attributes for anonymous users
        let nameInputRequired = '';
        let emailInputRequired = ''; // Email is optional
        let nameInputPlaceholder = "Name";
        let emailInputPlaceholder = "Email (Optional)";
        let nameInputValue = "";
        let emailInputValue = "";
        let nameInputReadOnly = "";
        let emailInputReadOnly = "";

        if (USER_IS_AUTHENTICATED) {
            nameInputValue = USER_FULL_NAME;
            emailInputValue = USER_EMAIL;
            nameInputReadOnly = "readonly";
            emailInputReadOnly = "readonly";
        } else {
            // For anonymous users, 'name' is required, 'email' is optional
            nameInputRequired = 'required';
        }

        // Construct the full input HTML strings
        const nameInputHtml = `<input type="text" name="name" placeholder="${nameInputPlaceholder}" value="${nameInputValue}" ${nameInputRequired} ${nameInputReadOnly}>`;
        const emailInputHtml = `<input type="email" name="email" placeholder="${emailInputPlaceholder}" value="${emailInputValue}" ${emailInputRequired} ${emailInputReadOnly}>`;
        
        return `
            <div class="comment ${commentData.parent_id ? 'comment-reply-item' : ''}" id="comment-${commentData.id}">
                <div class="comment-header">
                    <img src="${commentData.avatar_url || '/static/images/default_user_avatar.jpg'}" alt="${commentData.author}" class="comment-avatar">
                    <div>
                        <span class="comment-author">${commentData.author}</span>
                        <span class="comment-date">${commentData.created_at}</span>
                    </div>
                </div>
                <div class="comment-body">
                    <p>${commentData.content.replace(/\n/g, '<br>')}</p>
                </div>
                <button class="comment-reply" data-comment-id="${commentData.id}">Reply</button>
                <div class="comment-reply-form" id="reply-form-${commentData.id}" style="display: none;">
                    <form class="reply-inner-form" data-comment-id="${commentData.id}">
                        ${getCookie('csrftoken') ? '<input type="hidden" name="csrfmiddlewaretoken" value="' + getCookie('csrftoken') + '">' : ''}
                        <h3>Reply to ${commentData.author}</h3>
                        <div class="form-group">
                            <textarea name="content" placeholder="Write your reply..." required></textarea>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                ${nameInputHtml}
                            </div>
                            <div class="form-group">
                                ${emailInputHtml}
                            </div>
                        </div>
                        <input type="hidden" name="parent" value="${commentData.id}">
                        <input type="hidden" name="post" value="${blogPostId}">
                        <div class="reply-actions">
                            <button type="button" class="btn btn-secondary cancel-reply">Cancel</button>
                            <button type="submit" class="btn btn-primary submit-reply">Post Reply</button>
                        </div>
                    </form>
                </div>
                <div class="replies"></div> {# Container for nested replies #}
            </div>
        `;
    }

    // --- Handle comment reply buttons (Initial setup & Re-attach after AJAX) ---
    function setupCommentReplies() {
        console.log('Setting up comment reply listeners...');
        // Remove existing listeners to prevent duplicates before re-adding
        document.querySelectorAll('.comment-reply').forEach(button => {
            button.removeEventListener('click', toggleReplyForm);
        });
        document.querySelectorAll('.comment-reply-form form').forEach(form => {
            form.removeEventListener('submit', submitReplyForm);
            const cancelButton = form.querySelector('.cancel-reply');
            if (cancelButton) {
                cancelButton.removeEventListener('click', hideReplyForm);
            }
        });

        // Add new listeners
        document.querySelectorAll('.comment-reply').forEach(button => {
            button.addEventListener('click', toggleReplyForm);
        });

        document.querySelectorAll('.comment-reply-form form').forEach(replyInnerForm => {
            replyInnerForm.addEventListener('submit', submitReplyForm);
            const cancelButton = replyInnerForm.querySelector('.cancel-reply');
            if (cancelButton) {
                cancelButton.addEventListener('click', hideReplyForm);
            }
        });
    }

    // --- Toggle Reply Form Display ---
    function toggleReplyForm(e) {
        const commentId = e.target.dataset.commentId;
        const replyFormDiv = document.getElementById(`reply-form-${commentId}`);
        console.log('Toggling reply form for comment ID:', commentId, 'Form found:', !!replyFormDiv);

        if (!replyFormDiv) {
            console.error('Reply form container not found for comment ID:', commentId);
            return;
        }

        // Hide all other reply forms
        document.querySelectorAll('.comment-reply-form').forEach(form => {
            if (form.id !== `reply-form-${commentId}`) {
                form.style.display = 'none';
            }
        });

        const currentDisplay = replyFormDiv.style.display;
        replyFormDiv.style.display = currentDisplay === 'none' ? 'block' : 'none';

        if (replyFormDiv.style.display === 'block') {
            const parentInput = replyFormDiv.querySelector('input[name="parent"]');
            const postInput = replyFormDiv.querySelector('input[name="post"]');
            
            if (parentInput) parentInput.value = commentId;
            if (postInput) postInput.value = blogPostId; // Ensure correct blogPostId is passed
            console.log('Reply form opened. Parent:', parentInput.value, 'Post:', postInput.value);
        }
    }

    // --- Submit Reply Form ---
    async function submitReplyForm(e) {
        e.preventDefault();
        const replyForm = e.target;
        const parentCommentId = replyForm.dataset.commentId; // Get parent comment ID from form data-attribute
        console.log('Reply form submitted for parent comment ID:', parentCommentId);

        const submitButton = replyForm.querySelector('button[type="submit"]');
        const originalButtonText = submitButton.innerHTML;

        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Posting...';

        const formData = new FormData(replyForm);

        if (USER_IS_AUTHENTICATED) {
            formData.delete('name');
            formData.delete('email');
            console.log('User is authenticated, removed name/email from reply form data.');
        }

        try {
            // Use the main comment form action URL for replies as well
            // Assuming your Django view handles parent_id for nesting
            const response = await fetch(commentForm.action, { 
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });

            const result = await response.json();
            console.log('Reply form response:', result);

            if (result.success) {
                showToast('Reply posted successfully!', 'success');
                const newReplyHtml = createCommentElement(result.comment);

                // Update comment count
                if (commentsCountSpan) {
                    commentsCountSpan.textContent = parseInt(commentsCountSpan.textContent || '0') + 1;
                    console.log('Comments count updated (reply):', commentsCountSpan.textContent);
                }

                const parentCommentDiv = document.getElementById(`comment-${result.comment.parent_id}`);
                if (parentCommentDiv) {
                    let repliesContainer = parentCommentDiv.querySelector('.replies');
                    if (!repliesContainer) {
                        repliesContainer = document.createElement('div');
                        repliesContainer.className = 'replies';
                        parentCommentDiv.appendChild(repliesContainer);
                        console.log('Created new replies container for comment ID:', result.comment.parent_id);
                    }
                    repliesContainer.insertAdjacentHTML('beforeend', newReplyHtml);
                    console.log('Reply appended to parent comment ID:', result.comment.parent_id);
                } else {
                    console.warn('Parent comment div not found for reply:', result.comment.parent_id);
                    // Fallback: append to main list if parent not found (might happen with complex DOM operations)
                    commentsList.insertAdjacentHTML('afterbegin', newReplyHtml);
                }
                replyForm.reset();
                replyForm.closest('.comment-reply-form').style.display = 'none';

                setupCommentReplies(); // Re-attach listeners for newly added replies
            } else {
                if (result.errors) {
                    let errorMessages = '';
                    for (const field in result.errors) {
                        let fieldName = field.charAt(0).toUpperCase() + field.slice(1);
                        errorMessages += `${fieldName}: ${result.errors[field].join(', ')}\n`;
                    }
                    showToast(`Error: ${errorMessages.trim()}`, 'error');
                    console.error('Reply form submission errors:', result.errors);
                } else {
                    showToast('Failed to post reply. Please try again.', 'error');
                    console.error('Reply form submission failed:', result);
                }
            }
        } catch (error) {
            console.error('Network or server error submitting reply form:', error);
            showToast('A network error occurred. Please try again.', 'error');
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    }

    function hideReplyForm(e) {
        e.preventDefault();
        e.target.closest('.comment-reply-form').style.display = 'none';
        console.log('Reply form hidden.');
    }

    // --- Table of Contents Generation ---
    function generateTOC() {
        const postContent = document.querySelector('.post-content');
        // Corrected TOC list selector based on your HTML
        const tocList = document.querySelector('#toc-nav'); 
        if (!postContent || !tocList) {
            console.warn('TOC elements not found (post-content or #toc-nav). Skipping TOC generation.');
            return;
        }

        const headings = postContent.querySelectorAll('h2, h3, h4');
        tocList.innerHTML = ''; // Clear existing TOC items

        let currentUlStack = [tocList]; // Start with the main tocList as the first UL

        headings.forEach((heading, index) => {
            // Sanitize ID generation for robustness
            const id = `heading-${heading.tagName.toLowerCase()}-${index}-${heading.textContent.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-*|-*$/g, '').substring(0, 30)}`;
            heading.id = id;

            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = `#${id}`;
            a.textContent = heading.textContent;
            li.appendChild(a);

            const level = parseInt(heading.tagName.substring(1));
            // Get current level from the dataset, default to 0 if not set
            const currentStackLevel = parseInt(currentUlStack[currentUlStack.length - 1].dataset.level || 0);

            if (level === currentStackLevel) {
                // Same level: append to current UL
                currentUlStack[currentUlStack.length - 1].appendChild(li);
            } else if (level > currentStackLevel) {
                // Deeper level: create new UL and push to stack
                let newUl = document.createElement('ul');
                newUl.classList.add(`toc-sublist-level-${level - 1}`);
                newUl.dataset.level = level; // Store the current level for later comparison
                currentUlStack[currentUlStack.length - 1].appendChild(newUl);
                newUl.appendChild(li);
                currentUlStack.push(newUl);
            } else {
                // Higher level: pop from stack until correct level is found or back to root
                while (currentUlStack.length > 1 && level < parseInt(currentUlStack[currentUlStack.length - 1].dataset.level || 0)) {
                    currentUlStack.pop();
                }
                // Ensure the base level for tocList is correctly set if we jump significantly
                if (currentUlStack.length === 1 && level < parseInt(currentUlStack[0].dataset.level || 0)) {
                    currentUlStack[0].dataset.level = level;
                }
                currentUlStack[currentUlStack.length - 1].appendChild(li);
            }
            li.classList.add(`toc-${heading.tagName.toLowerCase()}`);
        });
        console.log('Table of Contents generated.');
    }


    // --- Highlight active TOC item on scroll ---
    function highlightActiveTOCItem() {
        const postContent = document.querySelector('.post-content');
        if (!postContent) return;

        const observer = new IntersectionObserver((entries) => {
            let activeLinkFound = false;
            entries.forEach(entry => {
                const id = entry.target.id;
                const tocLink = document.querySelector(`#toc-nav a[href="#${id}"]`); // Corrected TOC selector

                if (tocLink) {
                    // Consider an element active if it's mostly in view
                    if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
                        document.querySelectorAll('#toc-nav a').forEach(link => link.classList.remove('active')); // Corrected TOC selector
                        tocLink.classList.add('active');
                        activeLinkFound = true;

                        const tocContainer = document.querySelector('.toc-sidebar .toc-nav'); // Corrected TOC container for scroll
                        if (tocContainer) {
                            // Scroll TOC container to bring active link into view
                            const linkRect = tocLink.getBoundingClientRect();
                            const containerRect = tocContainer.getBoundingClientRect();
                            const scrollOffset = tocLink.offsetTop - tocContainer.offsetTop - (containerRect.height / 2) + (linkRect.height / 2);
                            tocContainer.scrollTo({ top: scrollOffset, behavior: 'smooth' });
                        }
                    }
                }
            });

            // Fallback: If no heading is >50% visible, highlight the first one currently visible
            if (!activeLinkFound) {
                const firstVisibleHeading = Array.from(postContent.querySelectorAll('h2[id], h3[id], h4[id]')).find(heading => {
                    const rect = heading.getBoundingClientRect();
                    return rect.top < window.innerHeight && rect.bottom > 0;
                });

                if (firstVisibleHeading) {
                    const tocLink = document.querySelector(`#toc-nav a[href="#${firstVisibleHeading.id}"]`); // Corrected TOC selector
                    if (tocLink && !tocLink.classList.contains('active')) {
                        document.querySelectorAll('#toc-nav a').forEach(link => link.classList.remove('active')); // Corrected TOC selector
                        tocLink.classList.add('active');
                    }
                }
            }
        }, { threshold: [0, 0.1, 0.5, 0.9, 1] }); // Observe at multiple thresholds

        document.querySelectorAll('.post-content h2[id], .post-content h3[id], .post-content h4[id]').forEach((section) => {
            observer.observe(section);
        });
        console.log('TOC highlighting initialized.');
    }

    // --- Smooth scroll for TOC links ---
    function setupTOCSmoothScroll() {
        document.querySelectorAll('#toc-nav a').forEach(link => { // Corrected TOC selector
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);

                if (targetElement) {
                    // Get fixed header height if it exists to offset scroll
                    const header = document.querySelector('header'); // Assuming your main header might be 'header' tag
                    const headerHeight = header ? header.offsetHeight : 0;

                    window.scrollTo({
                        top: targetElement.offsetTop - headerHeight - 20, // Offset for fixed header/nav and some padding
                        behavior: 'smooth'
                    });
                    console.log('Smooth scrolling to TOC item:', targetId);
                }
            });
        });
    }

    // --- Reading Progress Indicator ---
    function setupReadingProgress() {
        // Your HTML has the progress bar as a direct child of reading-progress div
        const progressBarElement = document.getElementById('progress-bar');
        if (!progressBarElement) {
            console.warn('Progress bar element (#progress-bar) not found. Skipping reading progress.');
            return;
        }
        
        window.addEventListener('scroll', () => {
            const documentHeight = document.documentElement.scrollHeight;
            const viewportHeight = window.innerHeight;
            const scrollPosition = window.scrollY;

            // Calculate progress, avoiding division by zero if content is very short
            let progress = 0;
            if (documentHeight > viewportHeight) {
                progress = (scrollPosition / (documentHeight - viewportHeight)) * 100;
            }
            
            progressBarElement.style.width = `${progress}%`;
        });
        console.log('Reading progress indicator initialized.');
    }

    // --- Back to Top Button ---
    function setupBackToTop() {
        // Your HTML uses .back-to-top class
        const backToTopButton = document.querySelector('.back-to-top'); 
        if (!backToTopButton) {
            console.warn('Back to top button (.back-to-top) not found. Skipping back to top functionality.');
            return;
        }
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) { // Show button after scrolling down 300px
                backToTopButton.classList.add('visible');
            } else {
                backToTopButton.classList.remove('visible');
            }
        });
        
        backToTopButton.addEventListener('click', (e) => {
            e.preventDefault();
            window.scrollTo({ top: 0, behavior: 'smooth' });
            console.log('Back to top button clicked.');
        });
    }

    // --- Smooth Scroll for General Anchor Links ---
    function setupSmoothScroll() {
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            // Exclude TOC links which are handled by setupTOCSmoothScroll
            // Also exclude comment buttons that use href="#" for placeholder behavior
            if (anchor.closest('#toc-nav') || anchor.classList.contains('scroll-to-comments')) return; 

            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                if (targetId === '#') return; // Ignore links that just go to the top of the page

                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    // Account for fixed header height if any
                    const headerHeight = document.querySelector('header')?.offsetHeight || 0;
                    const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - headerHeight - 20; // Added 20px padding
                    
                    window.scrollTo({ top: targetPosition, behavior: 'smooth' });
                    
                    // Update URL hash without jumping
                    if (history.pushState) {
                        history.pushState(null, null, targetId);
                    } else {
                        location.hash = targetId;
                    }
                    console.log('General smooth scroll to:', targetId);
                }
            });
        });
    }

    // --- Copy code blocks functionality ---
    function setupCodeCopyButtons() {
        document.querySelectorAll('pre').forEach(pre => {
            // Prevent adding multiple copy buttons to the same pre block
            if (pre.querySelector('.copy-code')) {
                return;
            }

            const button = document.createElement('button');
            button.className = 'copy-code';
            button.innerHTML = '<i class="far fa-copy"></i>'; // Font Awesome icon
            button.title = 'Copy code';

            button.addEventListener('click', () => {
                const code = pre.querySelector('code').innerText;
                // Use Clipboard API if available (more modern)
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(code).then(() => {
                        button.innerHTML = '<i class="fas fa-check"></i>'; // Checkmark icon
                        button.title = 'Copied!';
                        showToast('Code copied to clipboard!', 'success');
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy"></i>';
                            button.title = 'Copy code';
                        }, 2000); // Revert icon after 2 seconds
                    }).catch(err => {
                        console.error('Failed to copy text using clipboard API: ', err);
                        // Fallback to old method if modern API fails or is not available
                        fallbackCopyToClipboard(code, button);
                    });
                } else {
                    fallbackCopyToClipboard(code, button);
                }
            });

            // Position the button absolutely within the pre element
            pre.style.position = 'relative';
            pre.insertBefore(button, pre.firstChild); // Insert button before the code content
        });
        console.log('Code copy buttons initialized.');
    }

    // Fallback for copying text for older browsers or restricted environments
    function fallbackCopyToClipboard(text, button) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        // Make the textarea invisible and outside the viewport
        textArea.style.position = "fixed";
        textArea.style.left = "-9999px";
        textArea.style.top = "-9999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select(); // Select the text

        try {
            document.execCommand('copy'); // Execute the copy command
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.title = 'Copied!';
            showToast('Code copied to clipboard (fallback)!', 'success');
            setTimeout(() => {
                button.innerHTML = '<i class="far fa-copy"></i>';
                button.title = 'Copy code';
            }, 2000);
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            showToast('Failed to copy code. Please copy manually.', 'error');
        } finally {
            document.body.removeChild(textArea); // Clean up the textarea
        }
    }

    // --- Social share functionality ---
    function setupSocialSharing() {
        document.querySelectorAll('.share-btn, .social-btn').forEach(button => { // Included .social-btn
            button.addEventListener('click', function(e) {
                e.preventDefault();

                if (this.classList.contains('copy-link')) {
                    // Handle copy link specifically
                    const currentUrl = window.location.href.split('#')[0]; // Remove hash from URL
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(currentUrl).then(() => {
                            showToast('Link copied to clipboard!', 'success');
                        }).catch(err => {
                            console.error('Failed to copy link:', err);
                            // Fallback for older browsers or restricted environments
                            const tempInput = document.createElement('input');
                            document.body.appendChild(tempInput);
                            tempInput.value = currentUrl;
                            tempInput.select();
                            document.execCommand('copy');
                            tempInput.remove();
                            showToast('Link copied (fallback)!', 'success');
                        });
                    } else {
                        // Fallback for older browsers
                        const tempInput = document.createElement('input');
                        document.body.appendChild(tempInput);
                        tempInput.value = currentUrl;
                        tempInput.select();
                        document.execCommand('copy');
                        tempInput.remove();
                        showToast('Link copied (fallback)!', 'success');
                    }
                    return; // Stop further execution for copy link button
                }

                // Encode URL and title for use in query parameters
                const url = encodeURIComponent(window.location.href);
                const title = encodeURIComponent(document.querySelector('h1')?.innerText || document.title); // Fallback to document title

                let shareUrl = '';
                if (this.classList.contains('twitter')) {
                    shareUrl = `https://twitter.com/intent/tweet?url=${url}&text=${title}`;
                } else if (this.classList.contains('linkedin')) {
                    shareUrl = `https://www.linkedin.com/shareArticle?mini=true&url=${url}&title=${title}`;
                } else if (this.classList.contains('facebook')) {
                    shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${url}`;
                }

                if (shareUrl) {
                    // Open in a new small window for social sharing
                    window.open(shareUrl, '_blank', 'width=600,height=400,toolbar=no,menubar=no,status=no,location=no');
                    console.log('Sharing via:', this.classList[1], 'URL:', shareUrl);
                }
            });
        });
        console.log('Social sharing buttons initialized.');
    }

    // --- Initialize animations ---
    function initAnimations() {
        const animateElements = [
            ...document.querySelectorAll('.related-card, .comment, .comment-form, .author-card, .hero-title, .hero-meta, .breadcrumb, .scroll-indicator, .bio-avatar, .bio-content, .cta-content') // Added more elements from your HTML
        ];

        // Set initial state for animation (hidden and slightly offset)
        animateElements.forEach((el, index) => {
            // Check if element already has animate.css classes, if so, skip initial opacity/transform
            // as animate.css handles it
            if (!el.classList.contains('animate__animated')) {
                el.style.opacity = '0';
                el.style.transform = 'translateY(20px)';
                // Apply transition with a slight delay for staggered effect
                el.style.transition = `opacity 0.5s ease ${index * 0.05}s, transform 0.5s ease ${index * 0.05}s`; // Slightly faster stagger
            }
        });

        // Trigger initial fade-in after a short delay for elements that don't have animate.css
        setTimeout(() => {
            animateElements.forEach(el => {
                if (!el.classList.contains('animate__animated')) {
                    el.style.opacity = '1';
                    el.style.transform = 'translateY(0)';
                }
            });
        }, 100);

        // Observer for elements that come into view during scroll
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    // Apply animation class if not already animated by animate.css or custom JS
                    if (!entry.target.classList.contains('animate__animated')) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                    // For elements with animate.css classes, ensure they play
                    if (entry.target.classList.contains('animate__animated') && !entry.target.classList.contains('animate__done')) {
                        entry.target.classList.add('animate__done'); // Custom class to prevent re-triggering
                        // You might need to add a specific animation class here if not already in HTML
                        // e.g., entry.target.classList.add('animate__fadeInUp');
                    }
                    observer.unobserve(entry.target); // Stop observing once animated
                }
            });
        }, { threshold: 0.1 }); // Trigger when 10% of element is visible

        animateElements.forEach(el => {
            observer.observe(el);
        });
        console.log('Animations initialized.');
    }

    // --- Like Button Logic ---
    if (likeButton) {
        console.log('Like button element found (.like-btn). Attaching event listener.');
        likeButton.addEventListener('click', async function() {
            console.log('Like button clicked.');

            if (!USER_IS_AUTHENTICATED) {
                showToast('Please log in to like this post.', 'info');
                console.warn('Like failed: User not authenticated.');
                return;
            }
            
            // Use the postSlug from the global window object
            const likeUrl = `/blog/${postSlug}/like/`;
            console.log('Like API URL:', likeUrl);

            this.disabled = true; // Disable button to prevent multiple clicks
            // Optionally add a loading spinner
            const heartIcon = this.querySelector('.heart-icon');
            const originalHeartHTML = heartIcon.innerHTML;
            heartIcon.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';


            try {
                const response = await fetch(likeUrl, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken'),
                        'X-Requested-With': 'XMLHttpRequest' // Helps Django identify AJAX requests
                    },
                });

                if (!response.ok) { // Check for HTTP errors (4xx, 5xx)
                    const errorText = await response.text();
                    console.error('HTTP Error during like API call:', response.status, response.statusText, errorText);
                    showToast(`Error: ${response.status} ${response.statusText}`, 'error');
                    return; // Stop execution on HTTP error
                }

                const data = await response.json();
                console.log('Like API response data:', data);

                if (data.success) {
                    if (likeCountSpan) {
                        likeCountSpan.textContent = data.likes_count;
                        console.log('Like count updated to:', data.likes_count);
                    }

                    if (data.has_liked) {
                        this.classList.add('liked');
                        showToast(data.message || 'Post liked!', 'success');
                    } else {
                        this.classList.remove('liked');
                        showToast(data.message || 'Post unliked!', 'info');
                    }
                } else {
                    showToast(data.message || 'Failed to process like. Please try again.', 'error');
                    console.error('Like API returned success: false. Message:', data.message);
                }
            } catch (error) {
                console.error('Error liking post (network/parsing error):', error);
                showToast('A network error occurred while processing your like.', 'error');
            } finally {
                this.disabled = false; // Always re-enable button
                // Revert spinner to original heart icon
                if (heartIcon) {
                    heartIcon.innerHTML = originalHeartHTML;
                }
            }
        });
    } else {
        console.warn('Like button element (.like-btn) not found. Like functionality disabled.');
    }

    // --- Add scroll to comments for the comment-btn ---
    const scrollToCommentsBtn = document.querySelector('.comment-btn.scroll-to-comments');
    if (scrollToCommentsBtn) {
        scrollToCommentsBtn.addEventListener('click', function(e) {
            e.preventDefault();
            const commentsSection = document.getElementById('comments');
            if (commentsSection) {
                const header = document.querySelector('header');
                const headerHeight = header ? header.offsetHeight : 0;
                window.scrollTo({
                    top: commentsSection.offsetTop - headerHeight - 20, // Offset for fixed header and some padding
                    behavior: 'smooth'
                });
                console.log('Scrolled to comments section.');
            }
        });
    }


    // --- Main Initialization Function ---
    function initializeBlogDetailFeatures() {
        generateTOC();
        highlightActiveTOCItem();
        setupTOCSmoothScroll();
        setupCommentReplies(); // This function now handles initial and dynamic listeners
        setupCodeCopyButtons();
        setupSocialSharing();
        initAnimations();
        setupReadingProgress();
        setupBackToTop();
        setupSmoothScroll(); // For general anchor links
        
        console.log('All blog detail features initialized.');
    }

    initializeBlogDetailFeatures();
});
